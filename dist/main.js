/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/common/logger.ts":
/*!******************************!*\
  !*** ./src/common/logger.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoggerModule\": () => (/* binding */ LoggerModule),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n}\nvar _parseType = new WeakSet(), _log = new WeakSet();\nclass LoggerModule {\n    log(...message) {\n        _classPrivateMethodGet(this, _log, log).call(this, \"log\", ...message);\n    }\n    info(...message) {\n        _classPrivateMethodGet(this, _log, log).call(this, \"info\", ...message);\n    }\n    warn(...message) {\n        _classPrivateMethodGet(this, _log, log).call(this, \"warn\", ...message);\n    }\n    error(...message) {\n        _classPrivateMethodGet(this, _log, log).call(this, \"error\", ...message);\n    }\n    debug(...message) {\n        _classPrivateMethodGet(this, _log, log).call(this, \"debug\", ...message);\n    }\n    static create(name) {\n        return new LoggerModule(name);\n    }\n    constructor(name){\n        _parseType.add(this);\n        _log.add(this);\n        this.module = name;\n    }\n}\nfunction parseType(type) {\n    switch(type){\n        case \"info\":\n        case \"warn\":\n        case \"error\":\n        case \"debug\":\n            return type;\n        default:\n            return \"log\";\n    }\n}\nfunction log(type, ...message) {\n    console[_classPrivateMethodGet(this, _parseType, parseType).call(this, type)](`%c[HolyMod]%c %c[${this.module}]%c`, \"color: #fff133; font-weight: 700;\", \"\", \"color: #fff133;\", \"\", ...message);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoggerModule);\n\n\n//# sourceURL=webpack://holymod/./src/common/logger.ts?");

/***/ }),

/***/ "./src/renderer/classes/store.ts":
/*!***************************************!*\
  !*** ./src/renderer/classes/store.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Store)\n/* harmony export */ });\n/* harmony import */ var _common_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @common/logger */ \"./src/common/logger.ts\");\n/* harmony import */ var _modules_discord__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @modules/discord */ \"./src/renderer/modules/discord.ts\");\n\n\nclass Store {\n    has(event) {\n        return event in this.events;\n    }\n    on(event, listener) {\n        if (!this.has(event)) this.events[event] = new Set();\n        this.events[event].add(listener);\n        return ()=>void this.off(event, listener)\n        ;\n    }\n    off(event, listener) {\n        if (!this.has(event)) return;\n        return this.events[event].delete(listener);\n    }\n    emit(event, ...args) {\n        if (!this.has(event)) return;\n        const toFire = [\n            ...this.events[event]\n        ];\n        for(let index = 0; index < toFire.length; index++){\n            const listener = toFire[index];\n            try {\n                listener(...args);\n            } catch (error) {\n                this.logger.error(`Store:${this.constructor.name}`, error);\n            }\n        }\n    }\n    useEvent(event, factory, validate = ()=>true\n    ) {\n        const [state, setState] = _modules_discord__WEBPACK_IMPORTED_MODULE_1__[\"default\"].React.useState(factory());\n        _modules_discord__WEBPACK_IMPORTED_MODULE_1__[\"default\"].React.useEffect(()=>{\n            return this.on(event, (...args)=>validate(...args) && setState(factory())\n            );\n        }, [\n            event,\n            factory\n        ]);\n        return state;\n    }\n    constructor(){\n        this.logger = new _common_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"Store\");\n        this.events = {\n        };\n    }\n}\n\n\n\n//# sourceURL=webpack://holymod/./src/renderer/classes/store.ts?");

/***/ }),

/***/ "./src/renderer/data/modules.ts":
/*!**************************************!*\
  !*** ./src/renderer/data/modules.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    // React, Modules & Constants\n    Constants: {\n        props: [\n            \"API_HOST\",\n            \"ActionTypes\"\n        ]\n    },\n    React: {\n        props: [\n            \"createElement\",\n            \"isValidElement\"\n        ]\n    },\n    ReactDOM: {\n        props: [\n            \"render\",\n            \"createPortal\"\n        ]\n    },\n    ReactSpring: {\n        props: [\n            \"useSpring\",\n            \"Controller\",\n            \"animated\"\n        ]\n    },\n    Flux: {\n        type: \"MERGE\",\n        props: [\n            [\n                \"Store\",\n                \"Dispatcher\"\n            ],\n            [\n                \"connectStores\"\n            ]\n        ]\n    },\n    Dispatcher: {\n        props: [\n            \"dirtyDispatch\"\n        ]\n    },\n    ContextMenuActions: {\n        props: [\n            \"openContextMenu\"\n        ]\n    },\n    ModalsApi: {\n        props: [\n            \"openModal\",\n            \"useModalsStore\"\n        ]\n    },\n    ModalStack: {\n        props: [\n            \"push\",\n            \"popAll\"\n        ]\n    },\n    LocaleManager: {\n        props: [\n            \"Messages\",\n            \"getAvailableLocales\"\n        ],\n        ensure: (mod)=>mod.Messages.CLOSE\n    },\n    LocaleStore: {\n        props: [\n            \"locale\",\n            \"theme\"\n        ]\n    },\n    Lodash: {\n        props: [\n            \"zipObjectDeep\"\n        ]\n    },\n    MessageCreators: {\n        props: [\n            \"createBotMessage\"\n        ]\n    },\n    MessageActions: {\n        props: [\n            \"receiveMessage\"\n        ]\n    },\n    AvatarDefaults: {\n        props: [\n            \"BOT_AVATARS\"\n        ]\n    },\n    Moment: {\n        props: [\n            \"momentProperties\"\n        ]\n    },\n    // Stores\n    SelectedChannelStore: {\n        props: [\n            \"_dispatchToken\",\n            \"getChannelId\",\n            \"getLastSelectedChannelId\"\n        ]\n    },\n    // Components\n    ModalComponents: {\n        props: [\n            \"ModalRoot\",\n            \"ModalHeader\"\n        ]\n    },\n    Link: {\n        name: \"Anchor\"\n    },\n    Switch: {\n        name: \"Switch\"\n    },\n    SwitchItem: {\n        name: \"SwitchItem\"\n    },\n    TextInput: {\n        name: \"TextInput\"\n    },\n    SelectInput: {\n        name: \"SelectTempWrapper\"\n    },\n    Tooltips: {\n        props: [\n            \"TooltipContainer\"\n        ],\n        rename: [\n            {\n                from: \"default\",\n                to: \"Tooltip\"\n            },\n            {\n                from: \"TooltipContainer\",\n                to: \"Container\"\n            },\n            {\n                from: \"TooltipColors\",\n                to: \"Colors\"\n            },\n            {\n                from: \"TooltipPositions\",\n                to: \"Positions\"\n            },\n            {\n                from: \"TooltipLayer\",\n                to: \"Layer\"\n            }, \n        ]\n    },\n    Button: {\n        props: [\n            \"BorderColors\",\n            \"Colors\"\n        ]\n    },\n    Slider: {\n        name: \"Slider\"\n    },\n    ConfirmationModal: {\n        name: \"ConfirmModal\"\n    },\n    Text: {\n        name: \"Text\"\n    },\n    Markdown: {\n        name: \"Markdown\",\n        props: [\n            \"rules\"\n        ]\n    },\n    Caret: {\n        name: \"Caret\"\n    },\n    Forms: {\n        props: [\n            \"FormItem\",\n            \"FormTitle\"\n        ]\n    },\n    Flex: {\n        name: \"Flex\"\n    },\n    SearchBar: {\n        name: \"SearchBar\"\n    },\n    Spinner: {\n        name: \"Spinner\"\n    },\n    Scrollers: {\n        props: [\n            \"ScrollerAuto\",\n            \"ScrollerThin\",\n            \"default\"\n        ]\n    },\n    // Classes\n    Margins: {\n        props: [\n            \"marginXLarge\"\n        ]\n    },\n    FormClasses: {\n        props: [\n            \"formText\",\n            \"description\"\n        ]\n    },\n    // ContextMenu\n    ContextMenu: {\n        type: \"MERGE\",\n        props: [\n            [\n                \"openContextMenu\"\n            ],\n            [\n                \"MenuItem\",\n                \"MenuControlItem\"\n            ]\n        ],\n        rename: [\n            {\n                from: \"default\",\n                to: \"Menu\"\n            },\n            {\n                from: \"MenuItem\",\n                to: \"Item\"\n            },\n            {\n                from: \"MenuGroup\",\n                to: \"Group\"\n            },\n            {\n                from: \"MenuCheckboxItem\",\n                to: \"CheckboxItem\"\n            },\n            {\n                from: \"MenuSeparator\",\n                to: \"Separator\"\n            },\n            {\n                from: \"MenuCheckboxItem\",\n                to: \"CheckboxItem\"\n            },\n            {\n                from: \"MenuRadioItem\",\n                to: \"RadioItem\"\n            },\n            {\n                from: \"MenuStyle\",\n                to: \"Style\"\n            },\n            {\n                from: \"MenuControlItem\",\n                to: \"ControlItem\"\n            },\n            {\n                from: \"openContextMenu\",\n                to: \"open\"\n            },\n            {\n                from: \"closeContextMenu\",\n                to: \"close\"\n            }, \n        ]\n    },\n    PlaceholderClasses: {\n        props: [\n            \"emptyStateImage\",\n            \"emptyStateSubtext\"\n        ]\n    }\n});\n\n\n//# sourceURL=webpack://holymod/./src/renderer/data/modules.ts?");

/***/ }),

/***/ "./src/renderer/index.ts":
/*!*******************************!*\
  !*** ./src/renderer/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _common_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @common/logger */ \"./src/common/logger.ts\");\n/* harmony import */ var _modules_discord__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @modules/discord */ \"./src/renderer/modules/discord.ts\");\n/* harmony import */ var _modules_webpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @modules/webpack */ \"./src/renderer/modules/webpack.ts\");\n/* harmony import */ var _managers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./managers */ \"./src/renderer/managers/index.ts\");\n/* harmony import */ var _node_require__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node/require */ \"./src/renderer/node/require.ts\");\n/// <reference path=\"../../types.d.ts\" />\n\n\n\n\n\nconst Logger = new _common_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"Core\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new class HolyMod {\n    async start() {\n        await _modules_webpack__WEBPACK_IMPORTED_MODULE_2__[\"default\"].whenReady;\n        Logger.log(\"Initialize\");\n        Object.assign(window, {\n            require: _node_require__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n            React: _modules_discord__WEBPACK_IMPORTED_MODULE_1__[\"default\"].React,\n            ReactDOM: _modules_discord__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ReactDOM\n        });\n        _managers__WEBPACK_IMPORTED_MODULE_3__.Plugins.initialize();\n    }\n    stop() {\n    }\n});\n\n\n//# sourceURL=webpack://holymod/./src/renderer/index.ts?");

/***/ }),

/***/ "./src/renderer/managers/index.ts":
/*!****************************************!*\
  !*** ./src/renderer/managers/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Plugins\": () => (/* reexport safe */ _plugins__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"Themes\": () => (/* reexport safe */ _themes__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _plugins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins */ \"./src/renderer/managers/plugins.ts\");\n/* harmony import */ var _themes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./themes */ \"./src/renderer/managers/themes.ts\");\n\n\n\n\n//# sourceURL=webpack://holymod/./src/renderer/managers/index.ts?");

/***/ }),

/***/ "./src/renderer/managers/plugins.ts":
/*!******************************************!*\
  !*** ./src/renderer/managers/plugins.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _classes_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @classes/store */ \"./src/renderer/classes/store.ts\");\n/* harmony import */ var _common_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @common/logger */ \"./src/common/logger.ts\");\n/* harmony import */ var _modules_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @modules/storage */ \"./src/renderer/modules/storage.ts\");\n/* harmony import */ var _modules_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @modules/util */ \"./src/renderer/modules/util.ts\");\n/* harmony import */ var _node_module__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @node/module */ \"./src/renderer/node/module.ts\");\n/* harmony import */ var _node_require__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @node/require */ \"./src/renderer/node/require.ts\");\n\n\n\n\n\n\nconst { FS , Path  } = HolyAPI;\nconst Logger = new _common_logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"PluginsManager\");\nconst PluginsManager = new class PluginsManager extends _classes_store__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    initialize() {\n        this.loadAllPlugins();\n        this.enabledPlugins = new Set(Object.keys(_modules_storage__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"plugins\", {\n        })));\n    }\n    resolve(pluginOrId) {\n        if (typeof pluginOrId === \"string\") return this.plugins.get(pluginOrId);\n        return pluginOrId;\n    }\n    getManifest(filepath, filename) {\n        try {\n            return JSON.parse(FS.readFile(filepath, \"utf8\"));\n        } catch (error) {\n            Logger.error(`Failed to load manifest for ${filename}:`, error);\n            return null;\n        }\n    }\n    getEntryFile(filepath, manifest, filename) {\n        if (typeof manifest.entry === \"string\") {\n            const path = Path.resolve(filepath, manifest.entry);\n            if (FS.exists(path)) return path;\n        }\n        const found = this.extensions.find((ext)=>FS.exists(Path.resolve(filepath, \"index\" + ext))\n        );\n        if (found) return found;\n        Logger.error(`Failed to get entry file for ${filename}:`, new Error(\"Could not resolve entry file.\"));\n        return null;\n    }\n    loadAllPlugins() {\n        if (!FS.exists(this.folder)) {\n            Logger.log(\"Plugins folder doesn't exists, creating it...\");\n            try {\n                FS.createDirectory(this.folder);\n            } catch (error) {\n                Logger.error(\"Failed to create plugins directory:\", error);\n                return;\n            }\n        }\n        Logger.log(\"Loading plugins...\");\n        const filenames = FS.readDirectory(this.folder);\n        for(let i = 0; i < filenames.length; i++){\n            const filename = Path.resolve(this.folder, filenames[i]);\n            const manifestPath = Path.resolve(filename, \"manifest.json\");\n            if (!FS.exists(manifestPath)) continue;\n            this.loadPlugin(filename, true);\n        }\n    }\n    clearCache(location) {\n        if (!Path.isAbsolute(location)) location = Path.resolve(this.folder, location);\n        let current;\n        while(current = _node_require__WEBPACK_IMPORTED_MODULE_5__[\"default\"].resolve(location)){\n            delete _node_module__WEBPACK_IMPORTED_MODULE_4__[\"default\"].cache[current];\n        }\n    }\n    loadPlugin(filename, log = true) {\n        const manifestPath = Path.resolve(filename, \"manifest.json\");\n        const manifest = this.getManifest(manifestPath, Path.basename(filename));\n        if (!manifest) return;\n        const entryFile = this.getEntryFile(filename, manifest, Path.basename(filename));\n        const id = Path.basename(filename);\n        if (!entryFile) return;\n        let exports = {\n        };\n        try {\n            this.clearCache(filename);\n            const partialExports = (0,_node_require__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(entryFile);\n            exports = partialExports.__esModule ? partialExports.default : partialExports;\n            _modules_util__WEBPACK_IMPORTED_MODULE_3__[\"default\"].assign(exports.prototype, {\n                manifest: Object.freeze(manifest),\n                id: id,\n                displayName: manifest.name ?? id,\n                path: filename\n            });\n            exports = new exports();\n        } catch (error) {\n            return Logger.error(`Failed to compile ${manifest.name ?? id}:`, error);\n        }\n        if (log) {\n            Logger.log(`${exports.displayName} was loaded!`);\n        }\n        this.plugins.set(id, exports);\n        if (this.enabledPlugins.has(id)) {\n            this.startPlugin(id, true);\n        }\n    }\n    unloadPlugin(addon, log = true) {\n        const plugin = this.resolve(addon);\n        if (!plugin) return;\n        const success = this.stopPlugin(plugin);\n        this.plugins.delete(plugin.id);\n        this.clearCache(addon.path);\n        if (log) {\n            Logger.log(`${plugin.displayName} was unloaded!`);\n        }\n        return success;\n    }\n    startPlugin(addon, log = true) {\n        const plugin = this.resolve(addon);\n        if (!plugin) return;\n        try {\n            if (typeof plugin.onStart === \"function\") plugin.onStart();\n        } catch (error) {\n            Logger.error(`Could not start ${plugin.displayName}:`, error);\n            return false;\n        } finally{\n            if (log) {\n                Logger.log(`${plugin.displayName} was started!`);\n            }\n            return true;\n        }\n    }\n    stopPlugin(addon, log = true) {\n        const plugin = this.resolve(addon);\n        if (!plugin) return false;\n        try {\n            if (typeof plugin.onStop === \"function\") plugin.onStop();\n        } catch (error) {\n            Logger.error(`Failed to stop ${plugin.manifest.name}:`, error);\n            return false;\n        } finally{\n            if (log) {\n                Logger.log(`${plugin.manifest.name} was stopped!`);\n            }\n            return true;\n        }\n    }\n    reloadPlugin(addon) {\n        const plugin = this.resolve(addon);\n        if (!addon) return;\n        const success = this.unloadPlugin(plugin, false);\n        if (!success) {\n            return Logger.error(`Failed to reload plugin ${plugin.displayName}`);\n        }\n        this.loadPlugin(plugin.path, false);\n        Logger.log(`Reloaded ${plugin.displayName}`);\n    }\n    enablePlugin(addon, log = true) {\n        const plugin = this.resolve(addon);\n        if (!addon) return;\n        this.enabledPlugins.add(plugin.id);\n        this.saveState();\n        this.startPlugin(plugin, false);\n        if (log) {\n            Logger.log(`${plugin.displayName} was enabled!`);\n            this.emit(\"toggle\", plugin.id, true);\n        }\n    }\n    disablePlugin(addon, log = true) {\n        const plugin = this.resolve(addon);\n        if (!addon) return;\n        this.enabledPlugins.delete(plugin.id);\n        this.saveState();\n        this.stopPlugin(plugin, false);\n        if (log) {\n            Logger.log(`${plugin.displayName} was disabled!`);\n            this.emit(\"toggle\", plugin.id, false);\n        }\n    }\n    saveState() {\n        _modules_storage__WEBPACK_IMPORTED_MODULE_2__[\"default\"].set(\"plugins\", Object.fromEntries([\n            ...this.enabledPlugins.values()\n        ].map((key)=>[\n                key,\n                true\n            ]\n        )));\n    }\n    constructor(...args){\n        super(...args);\n        this.folder = Path.resolve(Path.getBasePath(), \"plugins\");\n        this.extensions = [\n            \".js\",\n            \".jsx\",\n            \".ts\",\n            \".tsx\",\n            \".mjs\"\n        ];\n        this.plugins = new Map();\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PluginsManager);\n\n\n//# sourceURL=webpack://holymod/./src/renderer/managers/plugins.ts?");

/***/ }),

/***/ "./src/renderer/managers/themes.ts":
/*!*****************************************!*\
  !*** ./src/renderer/managers/themes.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ThemesManager)\n/* harmony export */ });\nclass ThemesManager {\n    initialize() {\n    }\n}\n\n\n\n//# sourceURL=webpack://holymod/./src/renderer/managers/themes.ts?");

/***/ }),

/***/ "./src/renderer/modules/discord.ts":
/*!*****************************************!*\
  !*** ./src/renderer/modules/discord.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"promise\": () => (/* binding */ promise),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _register__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./register */ \"./src/renderer/modules/register.ts\");\n/* harmony import */ var _webpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpack */ \"./src/renderer/modules/webpack.ts\");\n/* harmony import */ var _data_modules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @data/modules */ \"./src/renderer/data/modules.ts\");\n\n\n\nconst DiscordModules = {\n};\nconst NOOP_RET = (_)=>_\n;\nconst filters = new Promise((resolve)=>{\n    const result = [];\n    for(let moduleId in _data_modules__WEBPACK_IMPORTED_MODULE_2__[\"default\"]){\n        const module = _data_modules__WEBPACK_IMPORTED_MODULE_2__[\"default\"][moduleId];\n        let filter = NOOP_RET, map = null;\n        if (Array.isArray(module.props)) {\n            switch(module.type){\n                case \"MERGE\":\n                    {\n                        let found = [];\n                        filter = (m)=>{\n                            const matches = module.props.some((props)=>props.every((prop)=>prop in m\n                                )\n                            );\n                            if (matches) found.push(m);\n                            return matches;\n                        };\n                        map = ()=>{\n                            return Object.assign({\n                            }, ...found);\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        filter = (m)=>module.props.every((prop)=>prop in m\n                            )\n                        ;\n                    }\n            }\n        }\n        if (module.rename) {\n            const current = map ?? NOOP_RET;\n            map = (mod)=>{\n                mod = current(mod);\n                const cloned = {\n                    ...mod\n                };\n                for (const { from , to  } of module.rename){\n                    cloned[to] = mod[from];\n                    delete cloned[from];\n                }\n                return cloned;\n            };\n        }\n        if (module.name) {\n            const current = filter;\n            filter = (mod)=>mod.displayName === module.name && current(mod)\n            ;\n        }\n        if (typeof module.ensure === \"function\") {\n            const current = filter;\n            filter = (mod)=>current(mod) && module.ensure(mod)\n            ;\n        }\n        if (typeof filter !== \"function\") continue;\n        result.push({\n            filter,\n            map,\n            id: moduleId\n        });\n    }\n    resolve(result);\n});\nconst promise = Promise.all([\n    filters,\n    _webpack__WEBPACK_IMPORTED_MODULE_1__[\"default\"].whenReady\n]).then(([filters1])=>{\n    const result = _webpack__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bulk(...filters1.map(({ filter  })=>filter\n    ));\n    Object.assign(DiscordModules, filters1.reduce((modules, { id , map  }, index)=>{\n        const mapper = map ?? NOOP_RET;\n        modules[id] = mapper(result[index]);\n        return modules;\n    }, {\n    }));\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiscordModules);\n\n\n//# sourceURL=webpack://holymod/./src/renderer/modules/discord.ts?");

/***/ }),

/***/ "./src/renderer/modules/injector.ts":
/*!******************************************!*\
  !*** ./src/renderer/modules/injector.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"injections\": () => (/* binding */ injections),\n/* harmony export */   \"validateOptions\": () => (/* binding */ validateOptions),\n/* harmony export */   \"createInjection\": () => (/* binding */ createInjection),\n/* harmony export */   \"resolveInjection\": () => (/* binding */ resolveInjection),\n/* harmony export */   \"inject\": () => (/* binding */ inject),\n/* harmony export */   \"getInjectionsByCaller\": () => (/* binding */ getInjectionsByCaller),\n/* harmony export */   \"uninject\": () => (/* binding */ uninject),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _common_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/logger */ \"./src/common/logger.ts\");\n\nconst Logger = new _common_logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"Injector\");\n/**@module Injector */ /**\r\n * @typedef InjectorOptions\r\n * @property {string} caller Caller for the injection, can be used multiple times.\r\n * @property {object|Function} module Module to inject into.\r\n * @property {string} method Method name to inject into, must be a property of {@property Module}\r\n */ /**\r\n * @typedef Injection\r\n * @property {object|function} module\r\n * @property {() => void} revert\r\n * @property {string} method\r\n * @property {function} originalMethod\r\n * @property {Array<InjectionChild>} children;\r\n */ /**\r\n * @typedef InjectionChild\r\n * @property {string} caller;\r\n * @property {(thisObject, params: any[], res) => any=} after;\r\n * @property {(thisObject, params: any[]) => any=} before;\r\n * @property {(types = [\"all\"]) => void} uninject;\r\n */ /**\r\n * All injections\r\n * @type {Array<Injection>}\r\n\r\n */ const injections = [];\n/**\r\n * Checks the arguments for the **inject** function.\r\n * @param {InjectorOptions} options \r\n * @returns {void}\r\n \r\n * @private Should only be used by the injector itself.\r\n */ function validateOptions(options) {\n    if (typeof options.caller !== \"string\") throw new Error(\"No caller for injection specified!\");\n    if (typeof options.module === \"undefined\") throw new Error(\"No module to injection specified!\");\n    if (typeof options.method === \"undefined\") throw new Error(\"No injection method specified!\");\n    if (typeof options.module[options.method] !== \"function\") throw new Error(`Method '${options.method}' appears to be '${typeof options.module[options.method]}' instead of 'function'!`);\n    if (Object.isFrozen(options.module)) throw new Error(\"Module appears to be readonly! Cannot injection into it.\");\n    if (![\n        \"before\",\n        \"after\"\n    ].some((opt)=>typeof options[opt] === \"function\"\n    )) throw new Error(\"No inject type specified!\");\n}\n/**\r\n * Injects into a module, pushes another inject into **{injections}**\r\n * @param {object|function} module The module to be injected\r\n * @param {string} method The name of any property in **{module}**\r\n * @returns {Injection}\r\n \r\n */ function createInjection(module, method) {\n    const originalMethod = module[method];\n    const injection = {\n        module,\n        method,\n        originalMethod: module[method],\n        children: [],\n        revert: ()=>{\n            const index = injections.indexOf(injection);\n            if (index < 0) return false;\n            module[method] = originalMethod;\n            injections.splice(index, 1);\n        }\n    };\n    module[method] = function(...params) {\n        if (!injection.children.length) {\n            injection.revert();\n            return originalMethod.apply(this, arguments);\n        }\n        const before = injection.children.filter((child)=>typeof child.before === \"function\" && !child.cancelBefore\n        );\n        const after = injection.children.filter((child)=>typeof child.after === \"function\" && !child.cancelAfter\n        );\n        let returnValue = params;\n        for (const injection2 of before){\n            try {\n                const tempReturn = injection2.before(this, returnValue);\n                if (Array.isArray(tempReturn)) returnValue = tempReturn;\n            } catch (exception) {\n                Logger.error(`Failed to run before injection for ${injection2.caller}:\\n`, exception);\n            }\n        }\n        if (Array.isArray(returnValue)) params = returnValue;\n        returnValue = originalMethod.apply(this, params);\n        for (const injection1 of after){\n            try {\n                const tempReturn = injection1.after(this, params, returnValue);\n                if (typeof tempReturn !== \"undefined\") returnValue = tempReturn;\n            } catch (exception) {\n                Logger.error(`Failed to run after injection for ${injection1.caller}:\\n`, exception);\n            }\n        }\n        return returnValue;\n    };\n    Object.assign(module[method], originalMethod, {\n        injection: {\n            uninject: injection.revert,\n            originalMethod\n        },\n        toString: ()=>originalMethod.toString()\n    });\n    injections.push(injection);\n    return injection;\n}\n/**\r\n * Resolves already existing injections / creates new injections.\r\n * @param {InjectorOptions} options Options provided for the injection process.\r\n * @returns {Injection}\r\n \r\n */ function resolveInjection(options) {\n    const { module , method  } = options;\n    let injection = injections.find((e)=>Object.is(e.module, module) && Object.is(e.method, method)\n    );\n    if (!injection) {\n        injection = createInjection(module, method);\n    }\n    return injection;\n}\n/**\r\n * Inject into any module that is the typeof Function|Object. \r\n * @param {InjectorOptions} options \r\n * @returns {void}\r\n \r\n * @example\r\n \r\n * ```js\r\n * import Injector from \"kernel/injector\";\r\n * import Logger from \"kernel/logger\";\r\n * \r\n * Injector.inject({\r\n *      caller: \"kernel-mod\",\r\n *      module: window.console,\r\n *      method: \"warn\",\r\n *      before: (thisObject, params, res) => {\r\n *          Logger.log(\"Patched message: \", params);\r\n *      }\r\n * });\r\n * ```\r\n */ function inject(options) {\n    validateOptions(options);\n    const injection = resolveInjection(options);\n    const child = {\n        ...options,\n        uninject: (types = [\n            \"all\"\n        ])=>{\n            const index = injection.children.indexOf(child);\n            if (index < 0) return false;\n            const foundChild = injection.children[index];\n            $loop: for (const type of types)switch(type){\n                case \"before\":\n                    foundChild.cancelBefore = true;\n                    continue $loop;\n                case \"after\":\n                    foundChild.cancelAfter = true;\n                    continue $loop;\n                case \"all\":\n                    injection.children.splice(index, 1);\n                    break $loop;\n            }\n            if (foundChild.cancelAfter && !foundChild.before || foundChild.cancelBefore && !foundChild.after) {\n                injection.children.splice(index, 1);\n            }\n        }\n    };\n    injection.children.push(child);\n    return child.uninject;\n}\n/**\r\n * Collects all injections by the **{caller}**\r\n * @param {string} caller Caller for injection to be resolved.\r\n * @returns {InjectionChild[]}\r\n \r\n */ function getInjectionsByCaller(caller) {\n    let found = [];\n    for (const injection of injections){\n        for (const child of injection.children){\n            if (Object.is(child.caller, caller)) found.push(child);\n        }\n    }\n    return found;\n}\n/**\r\n * Reverts the injection into a module by caller and method names.\r\n * @param {string} caller Caller for the injections. \r\n * @param {\"all\" | \"before\" | \"after\"} types Injection types.\r\n * @returns {boolean}\r\n \r\n */ function uninject(caller, types = [\n    \"all\"\n]) {\n    const injections1 = getInjectionsByCaller(caller);\n    if (!injections1.length) return false;\n    for (const child of injections1)child.uninject(types);\n    return true;\n}\n/**\r\n * Creates a injector specific for the choosen caller.\r\n * @param {string} caller Caller to for injections.\r\n */ function create(caller) {\n    if (typeof caller !== \"string\") throw new Error(`Caller must be a string, but got ${typeof caller} instead.`);\n    return {\n        inject: (options)=>inject(Object.assign({\n                caller\n            }, options))\n        ,\n        uninject: (types)=>uninject(caller, types)\n        ,\n        getInjectionsByCaller: ()=>getInjectionsByCaller(caller)\n    };\n}\nconst Injector = {\n    inject,\n    uninject,\n    validateOptions,\n    injections\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Injector);\n\n\n//# sourceURL=webpack://holymod/./src/renderer/modules/injector.ts?");

/***/ }),

/***/ "./src/renderer/modules/register.ts":
/*!******************************************!*\
  !*** ./src/renderer/modules/register.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./injector */ \"./src/renderer/modules/injector.ts\");\n/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ \"./src/renderer/modules/settings.ts\");\n/* harmony import */ var _webpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webpack */ \"./src/renderer/modules/webpack.ts\");\n\n\n\nObject.assign(window, {\n    HolyAPI: Object.assign({\n    }, HolyNative.requireModule(\"API\"), {\n        Webpack: _webpack__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n        Injector: _injector__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n        Settings: _settings__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    }),\n    HolyIPC: HolyNative.requireModule(\"IPC\")\n});\n\n\n//# sourceURL=webpack://holymod/./src/renderer/modules/register.ts?");

/***/ }),

/***/ "./src/renderer/modules/settings.ts":
/*!******************************************!*\
  !*** ./src/renderer/modules/settings.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SettingsRenderer)\n/* harmony export */ });\n/* harmony import */ var _injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./injector */ \"./src/renderer/modules/injector.ts\");\n/* harmony import */ var _webpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpack */ \"./src/renderer/modules/webpack.ts\");\n\n\nclass SettingsRenderer {\n    static registerPanel(id, options) {\n        const { label , render , order  } = options;\n        const tab = this.panels.find((e)=>e.id === id\n        );\n        if (tab) throw new Error(`Settings tab ${id} is already registered!`);\n        const panel = {\n            section: id,\n            label: label,\n            order: order,\n            className: `holy-settings-${id}-item`,\n            element: ()=>null\n        };\n        this.panels = this.panels.concat(panel).sort(this.sortPanels);\n        return ()=>{\n            const index = this.panels.indexOf(panel);\n            if (index < 0) return false;\n            this.panels.splice(index, 1);\n            return true;\n        };\n    }\n    static unregisterPanel(id) {\n        const panel = this.panels.findIndex((e)=>e.id === id\n        );\n        if (panel < 0) return;\n        this.panels.splice(panel, 1);\n    }\n    static sortPanels(a, b) {\n        return a.order - b.order;\n    }\n    static patchSettingsView() {\n        const SettingsView = _webpack__WEBPACK_IMPORTED_MODULE_1__[\"default\"].findByDisplayName(\"SettingsView\");\n        _injector__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inject({\n            caller: \"HolySettings\",\n            module: SettingsView.prototype,\n            method: \"getPredicateSections\",\n            after: (_, __, res)=>{\n                if (!Array.isArray(res) || !res.some((e)=>e?.section?.toLowerCase() === \"changelog\"\n                ) || res.some((s)=>s?.id === \"holy-settings\"\n                )) return;\n                const index = res.findIndex((s)=>s?.section?.toLowerCase() === \"changelog\"\n                ) - 1;\n                if (index < 0) return;\n                res.splice(index, 0, ...SettingsRenderer.defaultPanels.concat(SettingsRenderer.panels));\n            }\n        });\n    }\n}\nSettingsRenderer.defaultPanels = [\n    {\n        section: \"DIVIDER\"\n    },\n    {\n        section: \"HEADER\",\n        label: \"Holymod\"\n    }, \n];\nSettingsRenderer.panels = [];\n\n\n\n//# sourceURL=webpack://holymod/./src/renderer/modules/settings.ts?");

/***/ }),

/***/ "./src/renderer/modules/storage.ts":
/*!*****************************************!*\
  !*** ./src/renderer/modules/storage.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _classes_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @classes/store */ \"./src/renderer/classes/store.ts\");\n/* harmony import */ var _common_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @common/logger */ \"./src/common/logger.ts\");\n/* harmony import */ var _discord__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./discord */ \"./src/renderer/modules/discord.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/renderer/modules/util.ts\");\n\n\n\n\nconst Logger = new _common_logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Storage\");\nconst { Path , FS  } = HolyAPI;\nconst Storage = new class Storage extends _classes_store__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    initialize() {\n        if (!FS.exists(this.folder)) {\n            Logger.log(\"config folder was not found, creating one...\");\n            try {\n                FS.createDirectory(this.folder);\n            } catch (error) {\n                Logger.error(\"Failed to create config folder:\", error);\n            }\n        }\n    }\n    get(name, def) {\n        const { Lodash  } = _discord__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n        if (this.cache.has(name)) return Lodash.merge({\n        }, name, def);\n        const filepath = Path.resolve(this.folder, name + \".json\");\n        if (!FS.exists(filepath)) return def;\n        const data = _util__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadJSON(filepath);\n        if (data instanceof Error) {\n            Logger.error(`Data for ${name} is corrupt!`, data);\n            FS.createFile(filepath, \"{}\");\n            return def;\n        }\n        const final = Lodash.merge({\n        }, data, def);\n        this.cache.set(name, final);\n        return final;\n    }\n    set(name, value, emit = true) {\n        this.cache.set(name, value);\n        const filepath = Path.resolve(this.folder, name + \".json\");\n        try {\n            FS.createFile(filepath, JSON.stringify(value, null, \"\\t\"));\n        } catch (error) {\n            Logger.error(`Could not save data for ${name}:`, error);\n        }\n        if (emit) this.emit(\"data-changed\", name, value);\n    }\n    constructor(...args){\n        super(...args);\n        this.cache = new Map();\n        this.folder = Path.resolve(Path.getBasePath(), \"config\");\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Storage);\n\n\n//# sourceURL=webpack://holymod/./src/renderer/modules/storage.ts?");

/***/ }),

/***/ "./src/renderer/modules/util.ts":
/*!**************************************!*\
  !*** ./src/renderer/modules/util.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Utilities)\n/* harmony export */ });\nclass Utilities {\n    static loadJSON(file) {\n        try {\n            return JSON.parse(HolyAPI.FS.readFile(file, \"utf8\"));\n        } catch (error) {\n            return error;\n        }\n    }\n    static assign(object, ...properties) {\n        for(let i = 0; i < properties.length; i++){\n            const keys = Object.keys(properties[i]);\n            Object.defineProperties(object, Object.fromEntries(keys.map((key)=>[\n                    key,\n                    {\n                        value: properties[i][key],\n                        writeable: false,\n                        configurable: false\n                    }\n                ]\n            )));\n        }\n        return object;\n    }\n}\n\n\n\n//# sourceURL=webpack://holymod/./src/renderer/modules/util.ts?");

/***/ }),

/***/ "./src/renderer/modules/webpack.ts":
/*!*****************************************!*\
  !*** ./src/renderer/modules/webpack.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Filters\": () => (/* binding */ Filters),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// @ts-nocheck\nif (typeof Array.prototype.at !== \"function\") {\n    Array.prototype.at = function(index) {\n        return index < 0 ? this[this.length - Math.abs(index)] : this[index];\n    };\n}\nif (typeof setImmediate === \"undefined\") {\n    window.setImmediate = (callback)=>setTimeout(callback, 0)\n    ;\n}\nclass Filters {\n    static byProps(...props) {\n        return (module)=>props.every((prop)=>prop in module\n            )\n        ;\n    }\n    static byDisplayName(name, def = false) {\n        return (module)=>(def ? module = module.default : module) && typeof module === \"function\" && module.displayName === name\n        ;\n    }\n    static byTypeString(...strings) {\n        return (module)=>module.type && (module = module.type?.toString()) && strings.every((str)=>module.indexOf(str) > -1\n            )\n        ;\n    }\n}\nclass WebpackModule {\n    get Filters() {\n        return Filters;\n    }\n    get chunkName() {\n        return \"webpackChunkdiscord_app\";\n    }\n    get id() {\n        return \"holy-req\" + Math.random().toString().slice(2, 5);\n    }\n    async waitFor(filter, { retries =100 , all =false , forever =false , delay =50  } = {\n    }) {\n        for(let i = 0; i < retries || forever; i++){\n            const module = this.findModule(filter, {\n                all,\n                cache: false\n            });\n            if (module) return module;\n            await new Promise((res)=>setTimeout(res, delay)\n            );\n        }\n    }\n    parseOptions(args, filter = (thing)=>typeof thing === \"object\" && thing != null && !Array.isArray(thing)\n    ) {\n        return [\n            args,\n            filter(args.at(-1)) ? args.pop() : {\n            }\n        ];\n    }\n    request(cache = true) {\n        if (cache && this.cache) return this.cache;\n        let req = undefined;\n        if (Array.isArray(window[this.chunkName])) {\n            const chunk = [\n                [\n                    this.id\n                ],\n                {\n                },\n                (__nested_webpack_require_2006__)=>req = __nested_webpack_require_2006__\n            ];\n            webpackChunkdiscord_app.push(chunk);\n            webpackChunkdiscord_app.splice(webpackChunkdiscord_app.indexOf(chunk), 1);\n        }\n        if (!req) console.warn(\"[Webpack] Got empty cache.\");\n        if (cache) this.cache = req;\n        return req;\n    }\n    findModule(filter, { all =false , cache =true , force =false , default: defaultExports = false  } = {\n    }) {\n        if (typeof filter !== \"function\") return void 0;\n        const __nested_webpack_require_2526__ = this.request(cache);\n        const found = [];\n        let hasError = null;\n        if (!__nested_webpack_require_2526__) return;\n        const wrapFilter = function(module, index) {\n            try {\n                return filter(module, index);\n            } catch (error) {\n                hasError ??= error;\n                return false;\n            }\n        };\n        for(const id in __nested_webpack_require_2526__.c){\n            const module = __nested_webpack_require_2526__.c[id].exports;\n            if (!module || module === window) continue;\n            switch(typeof module){\n                case \"object\":\n                    {\n                        if (wrapFilter(module, id)) {\n                            if (!all) return module;\n                            found.push(module);\n                        }\n                        if (module.__esModule && module.default != null && wrapFilter(module.default, id)) {\n                            const exports = defaultExports ? module : module.default;\n                            if (!all) return exports;\n                            found.push(exports);\n                        }\n                        if (force && module.__esModule) for(const key in module){\n                            if (!module[key]) continue;\n                            if (wrapFilter(module[key], id)) {\n                                if (!all) return module[key];\n                                found.push(module[key]);\n                            }\n                        }\n                        break;\n                    }\n                case \"function\":\n                    {\n                        if (wrapFilter(module, id)) {\n                            if (!all) return module;\n                            found.push(module);\n                        }\n                        break;\n                    }\n            }\n        }\n        if (hasError) {\n            setImmediate(()=>{\n                console.warn(\"[Webpack] filter threw an error. This can cause lag spikes at the user's end. Please fix asap.\\n\\n\", hasError);\n            });\n        }\n        return all ? found : found[0];\n    }\n    findModules(filter) {\n        return this.findModule(filter, {\n            all: true\n        });\n    }\n    bulk(...options) {\n        const [filters, { wait =false , ...rest }] = this.parseOptions(options);\n        const found = new Array(filters.length);\n        const searchFunction = wait ? this.waitFor : this.findModule;\n        const wrappedFilters = filters.map((filter)=>{\n            if (Array.isArray(filter)) filter = Filters.byProps(...filter);\n            if (typeof filter === \"string\") filter = Filters.byDisplayName(filter);\n            return (m)=>{\n                try {\n                    return filter(m);\n                } catch (error) {\n                    return false;\n                }\n            };\n        });\n        const returnValue = searchFunction.call(this, (module)=>{\n            for(let i = 0; i < wrappedFilters.length; i++){\n                const filter = wrappedFilters[i];\n                if (typeof filter !== \"function\" || !filter(module) || found[i] != null) continue;\n                found[i] = module;\n            }\n            return found.filter(String).length === filters.length;\n        }, rest);\n        if (wait) return returnValue.then(()=>found\n        );\n        return found;\n    }\n    findByProps(...options) {\n        const [props, { bulk =false , wait =false , ...rest }] = this.parseOptions(options);\n        if (!bulk && !wait) {\n            return this.findModule(Filters.byProps(...props), rest);\n        }\n        if (wait && !bulk) {\n            return this.waitFor(Filters.byProps(...props), rest);\n        }\n        if (bulk) {\n            const filters = props.map((propsArray)=>Filters.byProps(...propsArray)\n            ).concat({\n                wait,\n                ...rest\n            });\n            return this.bulk(...filters);\n        }\n        return null;\n    }\n    findByDisplayName(...options) {\n        const [displayNames, { bulk =false , wait =false , ...rest }] = this.parseOptions(options);\n        if (!bulk && !wait) {\n            return this.findModule(Filters.byDisplayName(displayNames[0]), rest);\n        }\n        if (wait && !bulk) {\n            return this.waitFor(Filters.byDisplayName(displayNames[0]), rest);\n        }\n        if (bulk) {\n            const filters = displayNames.map(filters.map(Filters.byDisplayName)).concat({\n                wait,\n                cache\n            });\n            return this.bulk(...filters);\n        }\n        return null;\n    }\n    findIndex(filter) {\n        let foundIndex = -1;\n        this.findModule((module, index)=>{\n            if (filter(module)) foundIndex = index;\n        });\n        return foundIndex;\n    }\n    atIndex(index) {\n        return this.request(true)?.c[index];\n    }\n    get waitForGlobal() {\n        return new Promise(async (onExists)=>{\n            while(!Array.isArray(window[this.chunkName])){\n                await new Promise(setImmediate);\n            }\n            onExists();\n        });\n    }\n    /**@deprecated Use Webpack.whenReady.then(() => {}) instead. */ async wait(callback = null) {\n        return this.whenReady.then(()=>{\n            typeof callback === \"function\" && callback();\n        });\n    }\n    /**@deprecated Use Webpack.whenReady.then(() => {}) instead. */ get whenExists() {\n        return this.waitForGlobal;\n    }\n    /**@deprecated Use Webpack.whenReady.then(() => {}) instead. */ on(event, listener) {\n        switch(event){\n            case \"LOADED\":\n                return this.whenReady.then(listener);\n        }\n    }\n    /**@deprecated @see Webpack.on */ get once() {\n        return this.on;\n    }\n    constructor(){\n        this.cache = null;\n        this.whenReady = this.waitForGlobal.then(()=>new Promise(async (onReady)=>{\n                const [Dispatcher, { ActionTypes  } = {\n                }] = await this.findByProps([\n                    \"dirtyDispatch\"\n                ], [\n                    \"API_HOST\",\n                    \"ActionTypes\"\n                ], {\n                    cache: false,\n                    bulk: true,\n                    wait: true,\n                    forever: true\n                });\n                const listener = function() {\n                    Dispatcher.unsubscribe(ActionTypes.START_SESSION, listener);\n                    onReady();\n                };\n                Dispatcher.subscribe(ActionTypes.START_SESSION, listener);\n            })\n        );\n        window.HolyWebpack = this;\n    }\n}\nconst Webpack = new WebpackModule;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Webpack);\n\n\n//# sourceURL=webpack://holymod/./src/renderer/modules/webpack.ts?");

/***/ }),

/***/ "./src/renderer/node/module.ts":
/*!*************************************!*\
  !*** ./src/renderer/node/module.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cache\": () => (/* binding */ cache),\n/* harmony export */   \"nodeGlobals\": () => (/* binding */ nodeGlobals),\n/* harmony export */   \"globalPaths\": () => (/* binding */ globalPaths),\n/* harmony export */   \"createBindings\": () => (/* binding */ createBindings),\n/* harmony export */   \"extensions\": () => (/* binding */ extensions),\n/* harmony export */   \"Module\": () => (/* binding */ Module),\n/* harmony export */   \"resolve\": () => (/* binding */ resolve),\n/* harmony export */   \"createRequire\": () => (/* binding */ createRequire),\n/* harmony export */   \"getExtension\": () => (/* binding */ getExtension),\n/* harmony export */   \"resolveMain\": () => (/* binding */ resolveMain),\n/* harmony export */   \"getFilePath\": () => (/* binding */ getFilePath),\n/* harmony export */   \"load\": () => (/* binding */ load),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst { Path , FS , Compilers  } = HolyAPI;\nconst cache = {\n};\nconst nodeGlobals = [\n    \"require\",\n    \"module\",\n    \"exports\",\n    \"__filename\",\n    \"__dirname\",\n    \"global\"\n].join(\", \");\nconst globalPaths = [\n    Path.resolve(Path.getBasePath(), \"node_modules\")\n];\nconst createBindings = function(extensions1, handler) {\n    return Object.fromEntries(extensions1.map((ext)=>[\n            ext,\n            handler\n        ]\n    ));\n};\nconst extensions = {\n    ...createBindings([\n        \".js\",\n        \".jsx\",\n        \".mjs\"\n    ], (module, filename)=>{\n        const fileContent = Compilers.compileJS(filename);\n        module._compile(fileContent);\n        return module.exports;\n    }),\n    ...createBindings([\n        \".ts\",\n        \".tsx\"\n    ], (module, filename)=>{\n        const filecontent = Compilers.compileTS(filename);\n        module._compile(filecontent);\n        return module.exports;\n    }),\n    \".json\": (module, filename)=>{\n        const filecontent = FS.readFile(filename, \"utf8\");\n        module.exports = JSON.parse(filecontent);\n        return module.exports;\n    },\n    \".scss\": (module, filename)=>{\n        const content = Compilers.compileSCSS(filename);\n        module.exports = content;\n        return content;\n    },\n    \".css\": (module, filename)=>{\n        const content = FS.readFile(filename, \"utf8\");\n        module.exports = content;\n        return module.exports;\n    },\n    // I haven't tested this - I assume it works.\n    // TODO: Make this not shitty\n    \".node\": (module, filename)=>{\n        const thing = HolyAPI.unsafeExecuteJS(`require(${JSON.stringify(filename)})`);\n        module.exports = thing;\n        return thing;\n    }\n};\nclass Module {\n    _compile(code) {\n        const wrapped = window.eval(`(function (${nodeGlobals}) {\n            ${code}\n            //# sourceURL=${JSON.stringify(this.filename).slice(1, -1)}\n        })`);\n        wrapped(this.require, this, this.exports, this.filename, this.path, window);\n    }\n    constructor(id, parent){\n        this.id = id;\n        this.path = Path.dirname(id);\n        this.exports = {\n        };\n        this.parent = parent;\n        this.filename = id;\n        this.loaded = false;\n        this.children = [];\n        if (parent) parent.children.push(this);\n    }\n}\nfunction resolve(path) {\n    for(const key in cache){\n        if (key.startsWith(path)) return key;\n    }\n}\nfunction createRequire(_path, parent) {\n    const require = (mod)=>{\n        if (typeof mod !== \"string\") return;\n        switch(mod){\n            case \"@holy\":\n                return window.HolyAPI;\n            default:\n                {\n                    if (mod.startsWith(\"@holy/\")) {\n                        const value1 = mod.split(\"/\").slice(1).reduce((value, key)=>value[key]\n                        , window.HolyAPI);\n                        if (value1) return value1;\n                    }\n                    return load(_path, mod, parent);\n                }\n        }\n    };\n    Object.assign(require, {\n        cache,\n        resolve\n    });\n    // @ts-ignore\n    return require;\n}\nfunction hasExtension(mod) {\n    return Boolean(extensions[Path.extname(mod)]);\n}\nfunction getExtension(mod) {\n    return Path.extname(mod) || Object.keys(extensions).find((ext)=>FS.exists(mod + ext)\n    ) || \"\";\n}\nfunction collectPNPMStores(node_modules) {\n    const store = Path.resolve(node_modules, \".pnpm\");\n    if (!FS.exists(store) || !FS.getStats(store).isDirectory()) return [];\n    const result = [];\n    for (const file of FS.readDirectory(store)){\n        const fullPath = Path.resolve(store, file, \"node_modules\");\n        if (FS.exists(fullPath)) result.push(fullPath);\n    }\n    return result;\n}\nfunction resolveGlobalPath(mod, globalPaths1) {\n    const directMatch = globalPaths1.find((globalPath)=>FS.exists(Path.resolve(globalPath, mod))\n    );\n    if (directMatch) return directMatch;\n    const withExtension = globalPaths1.find((globalPath)=>getExtension(Path.resolve(globalPath, mod))\n    );\n    if (withExtension) return withExtension;\n    return \"\";\n}\nfunction getGlobalPath(mod) {\n    const fromGlobals = resolveGlobalPath(mod, globalPaths);\n    if (fromGlobals) return fromGlobals;\n    const allPaths = globalPaths.flatMap((globalPath)=>collectPNPMStores(globalPath)\n    );\n    const fromPNPM = resolveGlobalPath(mod, allPaths);\n    if (fromPNPM) return fromPNPM;\n    return \"\";\n}\nfunction getParent(_path, mod) {\n    const concatPath = Path.resolve(_path, mod);\n    const globalPath = Path.resolve(getGlobalPath(mod), mod);\n    if (FS.exists(concatPath)) return concatPath;\n    if (FS.exists(globalPath)) return globalPath;\n    return \"\";\n}\nfunction resolveMain(_path, mod) {\n    const parent = hasExtension(_path) ? Path.dirname(_path) : getParent(_path, mod);\n    if (!FS.exists(parent)) throw new Error(`Cannot find module ${mod}\\ntree:\\n\\r-${_path}`);\n    const files = FS.readDirectory(parent);\n    for (const file of files){\n        const ext = Path.extname(file);\n        if (file === \"package.json\") {\n            const pkg = JSON.parse(FS.readFile(Path.resolve(parent, file), \"utf8\"));\n            if (!Reflect.has(pkg, \"main\")) continue;\n            return Path.resolve(parent, hasExtension(pkg.main) ? pkg.main : pkg.main + getExtension(Path.resolve(parent, pkg.main)));\n        }\n        if (file.slice(0, -ext.length) === \"index\" && extensions[ext]) return Path.resolve(parent, file);\n    }\n    if (mod.startsWith(\"./\")) return null;\n    const globalMod = globalPaths.find((pth)=>FS.exists(Path.resolve(pth, mod))\n    );\n    if (globalMod) return resolveMain(globalMod, mod);\n    return globalPaths.find((pth)=>getExtension(Path.resolve(pth, mod))\n    );\n}\nfunction getFilePath(_path, mod) {\n    const combined = Path.resolve(_path, mod);\n    const pth = hasExtension(combined) ? combined : combined + getExtension(combined);\n    if (FS.exists(pth) && FS.getStats(pth).isFile()) return pth;\n    if (!hasExtension(mod)) return resolveMain(_path, mod);\n    return mod;\n}\nfunction load(_path, mod, req = null) {\n    const file = getFilePath(_path, mod);\n    if (!FS.exists(file)) throw new Error(`Cannot find module ${mod}\\ntree:\\n\\r-${_path}`);\n    if (cache[file]) return cache[file].exports;\n    const stats = FS.getStats(file);\n    if (stats.isDirectory()) mod = resolveMain(_path, mod);\n    const ext = getExtension(file);\n    const loader = extensions[ext];\n    if (!loader) throw new Error(`Cannot find module ${file}`);\n    const module = cache[file] = new Module(file, req);\n    const require = createRequire(Path.dirname(file), module);\n    module.require = require;\n    loader(module, file);\n    return module.exports;\n}\n// TODO: Add globalPaths support\nconst NodeModule = {\n    _extensions: extensions,\n    cache,\n    _load: load,\n    globalPaths: globalPaths\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NodeModule);\n\n\n//# sourceURL=webpack://holymod/./src/renderer/node/module.ts?");

/***/ }),

/***/ "./src/renderer/node/require.ts":
/*!**************************************!*\
  !*** ./src/renderer/node/require.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module */ \"./src/renderer/node/module.ts\");\n\nconst Require = (0,_module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(HolyAPI.Path.resolve(HolyAPI.Path.getBasePath(), \"plugins\"), null);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Require);\n\n\n//# sourceURL=webpack://holymod/./src/renderer/node/require.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/renderer/index.ts");
/******/ 	
/******/ })()
;